getwd()

setwd("/Users/akhiljoseph") 

getwd()

readlines <- function(...) {
  lapply(list(...), readline)
}

#input = readlines("Please Input Your Census API Key (Get a Free Census Api Key Here: <https://api.census.gov/data/key_signup.html>): ",
#"Enter the State(s) you want to calculate SVI for : ", "What Year would you like to calculate? (2009-2019 Are Available): ", "type a complete file path: ")

#input = readlines('9b463ea11801f35617597290aa63b5ce05f402b2', 'Indiana', '2010', '/Users/akhiljoseph')

API.key = '9b463ea11801f35617597290aa63b5ce05f402b2'
State = 'Indiana'
Year = 2010
dir.create(paste0(gsub("\\\\", "/", input[[4]]), "/Social_Vulnerability"))
setwd(paste0(gsub("\\\\", "/", input[[4]]), "/Social_Vulnerability")) 

#**Install and load required packages**
ReqPkgs <-
  c(
    'knitr',
    'sp',
    'sf',
    'spdep',
    'tidycensus',
    'dplyr',
    'tidyr',
    'mapview',
    'RColorBrewer',
    'leaflet',
    'leafpop',
    'ggplot2',
    'data.table'
  )

ReqPkgs <- as.list(ReqPkgs)

package.check <- lapply(
  ReqPkgs,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
#      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

options(tigris_use_cache = TRUE) 

### TidyCensus

#For this section you will use the `tidycensus` package to read in data from the American Community Survey, including geometry.

#Get a Free Census Api Key Here: <https://api.census.gov/data/key_signup.html>

tidycensus::census_api_key(key = API.key,
                           install = TRUE,
                           overwrite = TRUE)
readRenviron("~/.Renviron")

### List Counties in State

#Now were making a simple character vector to store the names of all the counties we'll be using to pull in the census data since no option exists to pull out blockgroup level data for the whole state.

'%notin%' <- Negate('%in%')
US.States <-
  as.list(
    c(
      'West Virginia',
      'Florida',
      'Illinois',
      'Minnesota',
      'Maryland',
      'Rhode Island',
      'Idaho',
      'New Hampshire',
      'North Carolina',
      'Vermont',
      'Connecticut',
      'Delaware',
      'New Mexico',
      'California',
      'New Jersey',
      'Wisconsin',
      'Oregon',
      'Nebraska',
      'Pennsylvania',
      'Washington',
      'Louisiana',
      'Georgia',
      'Alabama',
      'Utah',
      'Ohio',
      'Texas',
      'Colorado',
      'South Carolina',
      'Oklahoma',
      'Tennessee',
      'Wyoming',
      'Hawaii',
      'North Dakota',
      'Kentucky',
      'Maine',
      'New York',
      'Nevada',
      'Alaska',
      'Michigan',
      'Arkansas',
      'Mississippi',
      'Missouri',
      'Montana',
      'Kansas',
      'Indiana',
      'South Dakota',
      'Massachusetts',
      'Virginia',
      'District of Columbia',
      'Iowa',
      'Arizona'
    )
  )

Counties <- c()

if (States[[1]] == "USA") {
  States <- US.States
} else if (States %notin% US.States) {
  print("Please check state name(s) and try again, see the list of acceptable state names below:")
  print(as.character(US.States))
} else {
  States <- States
}

for (i in seq(1, length(States))) {
  State <- as.character(States[[i]])
  Counties[[i]] <- tigris::list_counties(state = State)
  names(Counties[[i]]) <- State
}

zctas <-c()
for (i in seq(1, length(States))) {
  State <- as.character(States[[i]])
  zctas[[i]] <- tigris::zctas(state = State, year= Year)
  names(zctas[[i]]) <- State
}


### List Variables To Be Pulled In

#Now were making a simple character vector to store the names of all the variables we'll be pulling in at the blockgroup and tract level, these were selected through a long process of trial an error

#Blockgroup Level Variables
varsBG <-
  c(
    'B25003_001',
    'B25003_003',
    'B25070_007',
    'B25070_008',
    'B25070_009',
    'B25070_010',
    'B25071_001',
    'B11007_001',
    'B11007_003',
    'B25034_001',
    'B25034_008',
    'B25034_009',
    'B25034_010',
    'B25034_011',
    'B01003_001',
    'B19301_001',
    'B25033_001',
    'B25033_006',
    'B25033_007',
    'B25033_012',
    'B25033_013',
    'B25044_001',
    'B25044_003',
    'B25044_010',
    'B23025_003',
    'B23025_005',
    'B25014_001',
    'B25014_005',
    'B25014_006',
    'B25014_007',
    'B25014_011',
    'B25014_012',
    'B25014_013',
    'B25024_001',
    'B25024_007',
    'B25024_008',
    'B25024_009',
    'B09021_022',
    'B09021_001',
    'B01001_020',
    'B01001_021',
    'B01001_022',
    'B01001_023',
    'B01001_024',
    'B01001_025',
    'B01001_044',
    'B01001_045',
    'B01001_046',
    'B01001_047',
    'B01001_048',
    'B01001_049',
    'B99163_001',
    'B99163_005',
    'B01001_003',
    'B01001_004',
    'B01001_005',
    'B01001_006',
    'B01001_027',
    'B01001_028',
    'B01001_029',
    'B01001_030',
    'B03002_003',
    'B02001_004',
    'B02001_001',
    'B02001_003',
    'B03003_003',
    'B02001_006',
    'B02001_007',
    'B02001_008',
    'B03002_003',
    'B03002_001',
    'B02001_001',
    'B25002_001',
    'B25002_003',
    'B15003_001',
    'B15003_016',
    'B15003_017',
    'B15003_018',
    'B15003_019',
    'B15003_020',
    'B15003_021',
    'B15003_022',
    'B15003_023',
    'B15003_024',
    'B15003_025',
    'B02001_005',
    'B03003_001',
    'B25070_001',
    'B17020_001',
    'C17002_001',
    'C17002_002',
    'C17002_003',
    'C17002_004'
  )

#Tract Level Variables
varsCT <-
  c(
    'B18101_025',
    'B18101_026',
    'B18101_006',
    'B18101_007',
    'C18130_009',
    'C18130_010',
    'C18130_016',
    'C18130_017',
    'B26001_001',
    'B11004_012',
    'B11004_018',
    'B09008_001',
    'B09008_010',
    'B09008_011',
    'B09008_012',
    'B17023_001',
    'B17023_016',
    'B17023_017',
    'B17023_018',
    'B22002_001'
  )


### Pulling in Block Group Level

#This chunk of code is pulling in all the blockgroup level variables described previously

print("Bringing in blockgroup data...")
CBG18_1 <- c()

zipcodes <- tigris::zctas(cb = TRUE, starts_with = c("46", "47"))
zipcodes <- zipcodes$ZCTA5CE10
print(zipcodes)

library(acs)
for (i in seq(1, length(zipcodes))) {
  CBG18_1[[i]] <- tidycensus::get_acs(
    #get_decentennial() pulls in data from the decentennial census 1990-2010
    geography = 'zcta',
    #other options include us, region, division, state, county subdivision, census tract, block, place, alaska native regional corporation, american indian area/alaska native area/hawaiian home land, american indian area/alaska native area (reservation or statistical entity only), american indian area (off-reservation trust land only)/hawaiian home land, metropolitan statistical area/micropolitan statistical area, combined statistical area, new england city and town area, combined new england city and town area, urban area, congressional district, school district (elementary, secondary or unified), public use microdata area, zip code tabulation area, and state legislative district (upper or lower chamber).
    state = State,
    county = NULL,
    zcta = '46202',
    #The county list created in the previous step
    survey = 'acs5',
    #could include the ACS 1, 3 or 5 year surveys
    year = Year,
    #2009 through 2018 are available. Defaults to 2018
    variables = varsBG,
    #The variable list created in the previous step, use tidycensus::load_variables to see what variables are available for the survey and or geography, there may be alternatives or others you want to add!
    geometry = FALSE,
    #if TRUE, uses the tigris package to return an sf tibble with simple feature geometry in the 'geometry' column. We use Tigris later to pull the geometry in.
    output = 'wide',
    key = API.key,
    show_call = TRUE
  )
}


CBG18_1 <- do.call("rbind", CBG18_1) 

